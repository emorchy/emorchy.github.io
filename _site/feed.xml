<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-07-13T14:54:39-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Ethan’s Blog</title><subtitle>This is the early stages of this site. Until I get a feel for the software and until I make my first project post, this description will remain up.</subtitle><author><name>Ethan Morchy</name></author><entry><title type="html">Automated Bug Hunting with Semgrep</title><link href="http://localhost:4000/talks/2024/07/10/semgrep-talk.html" rel="alternate" type="text/html" title="Automated Bug Hunting with Semgrep" /><published>2024-07-10T00:00:00-07:00</published><updated>2024-07-10T00:00:00-07:00</updated><id>http://localhost:4000/talks/2024/07/10/semgrep-talk</id><content type="html" xml:base="http://localhost:4000/talks/2024/07/10/semgrep-talk.html"><![CDATA[<div style="position:relative;padding-bottom:56.25%;">
    <!-- 56.25 comes from aspect ratio of 16:9, change this accordingly -->
    <iframe id="presentation_iframe" style="width:100%;height:100%;position:absolute;left:0px;top:0px;" frameborder="0" width="100%" height="100%" allowfullscreen="" allow="autoplay" src="/assets/files/semgrep/reactjs.html">
    </iframe>
</div>
<script>document.getElementById("presentation_iframe").focus();</script>

<center>Press "F" to enable fullscreen.</center>
<center>For more keyboard controls, press "?".</center>

<p>This presentation was compiled using “<a href="https://www.manim.community/">Manim</a>”, a mathematical animation engine. I used the <a href="https://manim-slides.eertmans.be/latest/index.html">Manim Slides</a> plugin for easy slide creation. The slides can be rendered with the python code found in my <a href="https://github.com/emorchy/semgrep-presentation">semgrep-presentation</a> repository.</p>]]></content><author><name>Ethan Morchy</name></author><category term="talks" /><category term="semgrep," /><category term="manim" /><summary type="html"><![CDATA[A presentation for the "Defcon 858" group about how a static analysis tool called Semgrep can be leveraged to find different vulnerabilities in a variety of languages.]]></summary></entry><entry><title type="html">Weather Station Protocol Forwarding</title><link href="http://localhost:4000/projects/2023/08/05/weather-station.html" rel="alternate" type="text/html" title="Weather Station Protocol Forwarding" /><published>2023-08-05T00:00:00-07:00</published><updated>2023-08-05T00:00:00-07:00</updated><id>http://localhost:4000/projects/2023/08/05/weather-station</id><content type="html" xml:base="http://localhost:4000/projects/2023/08/05/weather-station.html"><![CDATA[<style>
img + em {
  display: block;
  text-align: center;
  margin: auto;
}
img[alt=lacrosse.webp] { width: 100%; margin: auto;}
img.centered {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</style>

<h1 id="overview">Overview</h1>
<p>I used a 433MHz radio receiver and transmitter with an Attiny chip to interface an AcuRite weather transmitter with a La Crosse weather display.
<!--excerpt-->
I own a La Crosse weather transmitter and station. Several years ago, my transmitter stopped working. It wasn’t until recently when I began working on <a href="/2023/08/04/TPMS.html">another project</a> that I discovered a wireless weather transmission coming from nearby.</p>

<p><img src="/assets/files/weather/lacrosse.webp" alt="lacrosse.webp" class="centered" />
<em>La Crosse Weather Sensor and Station</em></p>
<h1 id="code-creation">Code Creation</h1>
<h2 id="receive-acurite">Receive Acurite</h2>
<p>Using a RTL-SDR with the “rtl_433” program, I was able to see that someone owned a weather station in the general vicinity.
<img src="/assets/files/weather/rtl.png" alt="rtl.png" class="centered" />
<em>rtl_433 output</em></p>

<p>From the output, my neighbor owns an AcuRite 5-in-1 weather sensor. This device transmits temperature, humidity, wind speed, wind direction, and rainfall on the 433MHz frequency. Every 30 seconds, an AcuRite transmitter will send 3 identical messages (not including the sequence number). An AcuRite weather station (usually some sort of display) will demodulate and process the received data into a handy human-readable display.</p>
<h3 id="demodulation">Demodulation</h3>
<!--
![5in1.png](/assets/files/weather/5in1.png){:.centered}
*AcuRite 5-in-1 Weather Station*
-->
<p>To receive AcuRite data using an arduino (or attiny chip), a 433 MHz receiver must connect to the microcontroller. I will be using the <a href="https://github.com/sui77/rc-switch/wiki">RC Switch</a> library, which can be used send and receive RC codes.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;RCSwitch.h&gt;</span><span class="cp">
</span><span class="n">RCSwitch</span> <span class="n">receiver</span> <span class="o">=</span> <span class="n">RCSwitch</span><span class="p">();</span>
<span class="o">---</span><span class="n">snip</span><span class="o">---</span>
<span class="kt">void</span> <span class="nf">receive</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">receiver</span><span class="p">.</span><span class="n">enableReceive</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// Receiver on interrupt 0 =&gt; that is pin #2</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">RCSwitch</span><span class="o">::</span><span class="n">Protocol</span> <span class="n">acurite</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">204</span><span class="p">,</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="nb">false</span> <span class="p">};</span>
  <span class="n">receiver</span><span class="p">.</span><span class="n">setProtocol</span><span class="p">(</span><span class="n">acurite</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">receiver</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{};</span>
  <span class="n">receiver</span><span class="p">.</span><span class="n">resetAvailable</span><span class="p">();</span>
<span class="o">---</span><span class="n">snip</span><span class="o">---</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">receive()</code> function first enables the receiver on pin #2. In order to differentiate an AcuRite transmission from random noise, the protocol uses <a href="https://en.wikipedia.org/wiki/Pulse-width_modulation#Telecommunications">Pulse Width Modulation</a>. As a quick AcuRite PWM crash course, data is read one bit every clock cycle. In each cycle, a digital 1 is represented by a short pulse, and a digital 0 is represented by a long pulse. Thanks to rtl_433, we are able to <a href="https://triq.org/pdv/#AAB00B0404026000D4019027148055+AAB04B0401026000D401902714929292929292A1A1A192A1929292A19292A1A1A1A19292929292929292929292A19292A1A192A19292A1A1A192A1A1A1A19292A1A19292A1A1A1929292A1A1A19055+AAB00B0404026000D4019027148055+AAB04B0401026000D401902714929292A19292A1A1A192A1929292A19292A1A1A1A19292929292929292929292A19292A1A192A19292A1A1A192A1A1A1A19292A1A19292A1A1A192A192A1A1A19055+AAB00B0404026000D4019027148055+AAB04B0401026000D4019027149292A1929292A1A1A192A1929292A19292A1A1A1A19292929292929292929292A19292A1A192A19292A1A1A192A1A1A1A19292A1A19292A1A1A1A19292A1A1A19355">visualize the pulsedata</a> coming from Acurite.
<img src="/assets/files/weather/triq.png" alt="triq.png" class="centered" />
<em>Acurite PWM visualization</em>
As shown above on the right side, a bit is read every 612ms.</p>

<p><em>Note</em>: There is a margin of error for received pulse data. I set the pulse length to two short pulses equal one long pulse.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    __
0: |  |_ : long high pulse (~408ms), short low pulse (~204ms)
    _
1: | |__ : short high pulse (~204ms), long low pulse (~408ms)
</code></pre></div></div>
<p>The acurite protocol definition is in the format: {pulselength, Sync bit, “0” bit, “1” bit, invertedSignal}. Given that each bit is composed of 3 short pulses (204ms * 3 = 612ms):</p>

<table>
  <tbody>
    <tr>
      <td>pulselength</td>
      <td>204ms</td>
    </tr>
    <tr>
      <td>Off bit</td>
      <td>{2,1} #2 high pulses, 1 low pulse</td>
    </tr>
    <tr>
      <td>On bit</td>
      <td>{1,2} #1 high pulse, 2 low pulses</td>
    </tr>
    <tr>
      <td>sync header</td>
      <td>3 high pulses and 3 low pulses x4 (612ms up, 612ms down) x4</td>
    </tr>
    <tr>
      <td>invertedSignal</td>
      <td>false</td>
    </tr>
  </tbody>
</table>

<h3 id="decoding">Decoding</h3>
<p>As mentioned before, 3 near-identical messages are released every 30 seconds. Here is an example message set:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[01] {65} 03 a2 78 00 88 36 d2 ad 00 
[02] {65} 13 a2 78 00 88 36 d2 bd 00 
[03] {65} 23 a2 78 00 88 36 d2 cd 00 
</code></pre></div></div>

<p>Once again, the rtl_433 repository proves invaluable with the Acurite data decoding. The <a href="https://github.com/merbanan/rtl_433/blob/master/src/devices/acurite.c#L632C1-L695">acurite.c</a> that exists in the rtl_433 repository demonstrates the decoding process of an Acurite message.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{65} 03 a2 78 00 88 36 d2 ad 00 
 ^^ sync byte (in buf as item 0)
     ^^ ^^ ^^ id, seq, status, etc
              ^^ ^^ wind speed
                 ^^ ^^ temperature
                       ^^ humidity
</code></pre></div></div>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">receive</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">---</span><span class="n">snip</span><span class="o">---</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span> <span class="o">==</span> <span class="mi">56</span><span class="p">){</span> <span class="c1">//correct message type</span>
      <span class="kt">bool</span> <span class="n">failure</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">temp_raw</span> <span class="o">=</span> <span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span> <span class="o">|</span> <span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">);</span>
      <span class="kt">float</span> <span class="n">tempf</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp_raw</span> <span class="o">-</span> <span class="mi">400</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span><span class="n">f</span><span class="p">;</span>
      <span class="kt">uint8_t</span> <span class="n">humidity</span> <span class="o">=</span> <span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">humidity</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">humidity</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">||</span> <span class="n">tempf</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">40</span> <span class="o">||</span> <span class="n">tempf</span> <span class="o">&gt;</span> <span class="mi">158</span><span class="p">)</span> <span class="p">{</span><span class="n">failure</span> <span class="o">=</span> <span class="nb">true</span><span class="p">};</span> <span class="c1">//data sanity</span>
  <span class="p">}</span>
  <span class="o">---</span><span class="n">snip</span><span class="o">---</span>
</code></pre></div></div>
<h2 id="transmit-la-crosse">Transmit La Crosse</h2>
<p>Now that we have temperature and humidity stored in a variable, it is time to transmit the data to the La Crosse weather station. I emulated the La Crosse TX141TH-Bv2 sensor. From the description in <a href="https://github.com/merbanan/rtl_433/blob/master/src/devices/lacrosse_tx141x.c#L33-L47">lacrosse_tx141x.c</a>, we can gather a PWM profile for rc-switch:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RCSwitch</span> <span class="n">transmitter</span> <span class="o">=</span> <span class="n">RCSwitch</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">transmit</span><span class="p">(</span><span class="kt">float</span> <span class="n">tempc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">humi</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">transmitter</span><span class="p">.</span><span class="n">enableTransmit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//arduino pin #10</span>
  <span class="n">transmitter</span><span class="p">.</span><span class="n">setRepeatTransmit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//disables repeat</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">RCSwitch</span><span class="o">::</span><span class="n">Protocol</span> <span class="n">sync</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">833</span><span class="p">,</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="nb">false</span> <span class="p">};</span>      <span class="c1">//833ms apart</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">RCSwitch</span><span class="o">::</span><span class="n">Protocol</span> <span class="n">lacrosse</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">208</span><span class="p">,</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="nb">false</span> <span class="p">};</span>
<span class="o">---</span><span class="n">snip</span><span class="o">---</span>
</code></pre></div></div>

<p>I created a different protocol for the sync header because the preamble is 833ms high and 833ms low repeated 4 times. RCSwitch does not allow repeated sync packets, so I used a different protocol for sync. Following the <a href="https://github.com/merbanan/rtl_433/blob/master/src/devices/lacrosse_tx141x.c#L58-L64">La Crosse transmission analysis</a>, the protocol can be coded as such:</p>
<center>
<code>
[id] [id] [flags] [temp] [temp] [temp] [humi] [humi] [chk] [chk]
</code>
</center>
<center><p>Every 4 bits of data is enclosed in [ ] for a total of 40 bits.</p></center>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">---</span><span class="n">snip</span><span class="o">---</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">setProtocol</span><span class="p">(</span><span class="n">sync</span><span class="p">);</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"1111"</span><span class="p">);</span>  <span class="c1">//initial sync of 4x 833us high and low</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">setProtocol</span><span class="p">(</span><span class="n">lacrosse</span><span class="p">);</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>       <span class="c1">//bogus nonzero ID;</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"1001"</span><span class="p">);</span>        <span class="c1">//flags: battery 0 (!1), test 0, channel 01</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">temp_raw</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>  <span class="c1">//12 bit packet</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">humi</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>       <span class="c1">//8 bit packet</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"11111111"</span><span class="p">);</span>    <span class="c1">//dummy CRC is unchecked</span>
<span class="o">---</span><span class="n">snip</span><span class="o">---</span>
</code></pre></div></div>

<p>According to <a href="https://github.com/merbanan/rtl_433/blob/master/src/devices/lacrosse_tx141x.c#L50-L52">rtl_433</a>, “The TX141TH-Bv2 sensor sends 12 of identical packets, one immediately following the other, in a single burst. These 12-packet bursts repeat every 50 seconds”. The final transmission function is shown below:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">transmit</span><span class="p">(</span><span class="kt">float</span> <span class="n">tempc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">humi</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">transmitter</span><span class="p">.</span><span class="n">enableTransmit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//arduino pin #10</span>
  <span class="n">transmitter</span><span class="p">.</span><span class="n">setRepeatTransmit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//disables repeat</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">RCSwitch</span><span class="o">::</span><span class="n">Protocol</span> <span class="n">sync</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">833</span><span class="p">,</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="nb">false</span> <span class="p">};</span>      <span class="c1">//833ms apart</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">RCSwitch</span><span class="o">::</span><span class="n">Protocol</span> <span class="n">lacrosse</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">208</span><span class="p">,</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="nb">false</span> <span class="p">};</span>

  <span class="kt">int</span> <span class="n">temp_raw</span> <span class="o">=</span> <span class="n">tempc</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">500</span><span class="p">;</span> <span class="c1">//converts Celcius to La Crosse 12 bits</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//12 repeated packets</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">setProtocol</span><span class="p">(</span><span class="n">sync</span><span class="p">);</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"1111"</span><span class="p">);</span>  <span class="c1">//initial sync of 4x 833us high and low</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">setProtocol</span><span class="p">(</span><span class="n">lacrosse</span><span class="p">);</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>       <span class="c1">//bogus nonzero ID;</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"1001"</span><span class="p">);</span>        <span class="c1">//flags: battery 0 (!1), test 0, channel 01</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">temp_raw</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>  <span class="c1">//12 bit packet</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">humi</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>       <span class="c1">//8 bit packet</span>
    <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"11111111"</span><span class="p">);</span>    <span class="c1">//dummy CRC is unchecked</span>
  <span class="p">}</span>
  <span class="n">transmitter</span><span class="p">.</span><span class="n">setProtocol</span><span class="p">(</span><span class="n">sync</span><span class="p">);</span>
  <span class="n">transmitter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"11"</span><span class="p">);</span>  <span class="c1">//post-amble 2x 833us high and low</span>
  <span class="n">transmitter</span><span class="p">.</span><span class="n">disableTransmit</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Ethan Morchy</name></author><category term="projects" /><category term="rf" /><summary type="html"><![CDATA[Overview I used a 433MHz radio receiver and transmitter with an Attiny chip to interface an AcuRite weather transmitter with a La Crosse weather display.]]></summary></entry><entry><title type="html">PicoCTF Power Analysis</title><link href="http://localhost:4000/writeups/2023/03/30/picoctf-poweranalysis.html" rel="alternate" type="text/html" title="PicoCTF Power Analysis" /><published>2023-03-30T00:00:00-07:00</published><updated>2023-03-30T00:00:00-07:00</updated><id>http://localhost:4000/writeups/2023/03/30/picoctf-poweranalysis</id><content type="html" xml:base="http://localhost:4000/writeups/2023/03/30/picoctf-poweranalysis.html"><![CDATA[<h1 id="poweranalysiswarm">PowerAnalysisWarm</h1>
<details open="">
<summary>Description</summary>
<br />
This encryption algorithm leaks a "bit" of data every time it does a computation. Use this to figure out the encryption key.

Additional details will be available after launching your challenge instance.
</details>

<h2 id="precursor">Precursor</h2>
<h3 id="what-is-aes">What is AES?</h3>
<p>Advanced Encryption Standard (AES) is a symmetric-key block cipher used in VPNs, drive encryption, and government information protection. It is the most used encryption cipher used to date, and the versatility of its base leads to different varieties according to specific needs.</p>
<h3 id="why-aes">Why AES?</h3>
<p>Because of its properties, this algorithm easily and quickly allows data to be encrypted and decrypted at will when a key is known. AES is a worldwide algorithm that works great, when it is not improperly configured. Several attacks are known for insecure AES, including side channel attacks (which we will be discussing later on).</p>
<h3 id="how-aes">How AES?</h3>
<p>Let’s say Alice wants to securely send a simple 16 byte message to Bob using AES.</p>

<p>Alice decides to create a 16 byte key that will encrypt the message she sends to Bob. She settles on the following:</p>

<p>Key: “My precious key!”</p>

<p>Plaintext: “Are belong to us”</p>

<p><img src="/assets/files/picoctf/aes.png" alt="AES" /></p>
<h4 id="xor">XOR</h4>
<p>Alice first converts the key and the plaintext to hex:</p>

<p>Key: 4d792070726563696f7573206b657921</p>

<p>Plaintext: 4172652062656c6f6e6720746f207573</p>

<p><br />
She then begins by XORing the plaintext and the key.</p>

<p>Ex. First byte: 0x4d XOR 0x41 = 0x0c</p>

<p>Second byte: 0x79 XOR 0x72 = 0x0b
  <br />
  <br />
Key XOR Plaintext = 0c0b455010000f060112535404450c52</p>
<h4 id="sub-bytes">Sub-bytes</h4>
<p>Next, Alice takes each byte in the XORed result and matches it with a substitution box (S-box). Because the first byte of the XORed value is 0x0c, Alice indexes the 13th value in the S-box and substitutes it for 0x0c.</p>

<p>Luckily, the AES S-box is a standard lookup table originating from the <a href="https://en.wikipedia.org/wiki/Rijndael_S-box">Rijndael S-box</a>.</p>

<p><img src="/assets/files/picoctf/sbox.png" alt="S-box" /></p>

<p>The left column indexes with first half byte and the top row indexes using the last half byte of the input.</p>

<p>Ex. “0c” would be substituted for “fe”.</p>

<p>Sub-bytes = fe2b6e53ca63766f7cc9ed20f26efe00</p>

<p>Although there are subsequent steps involved during the encryption process, this challenge focuses specifically on the XOR and S-box lookup in AES.</p>

<h3 id="where-aes">Where AES?</h3>

<p>The function “leaky_aes_secret” in <code class="language-plaintext highlighter-rouge">encrypt.py</code> demonstrates where AES is used:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def leaky_aes_secret(data_byte, key_byte):
    out = Sbox[data_byte ^ key_byte]
    leak_buf.append(out &amp; 0x01)
    return out
</code></pre></div></div>

<p>The second line appears to be the combination of both AES steps previously defined. Additionally, the line after will leak the last bit of every substituted byte and later find the sum of the bits.</p>

<p>Per our example, the least significant bits of Sub-bytes would be: 0101010101100000</p>

<p>The sum (6) would subsequently be leaked with the line: <code class="language-plaintext highlighter-rouge">leakage result: 6</code></p>

<p>The challenge essentially asks one question: When we are given the sum of least significant bits after providing a plaintext, is it possible to find the encryption key?</p>

<h2 id="theory">Theory</h2>
<p>We are dealing with a <a href="https://en.wikipedia.org/wiki/Side-channel_attack">side channel attack</a>. The least significant bit of each byte is calculated and the total is leaked to the user.</p>

<p><img src="/assets/files/picoctf/algo.png" alt="algorithm" /></p>

<p>View example on <a href="https://github.com/emorchy/PicoCTF2023-PowerAnalysis/blob/main/README.md#Theory">my github repo</a>.</p>

<p>How do we find the key from the result?</p>

<h2 id="isolating-the-lsbs">Isolating the LSBs</h2>
<p>We must first control the leak to find the key. To do this, we must be able to correspond individual bytes to bit leakage. By providing a payload that returns 0 bits of leakage, we can move on to the next step of manipulating individual bytes.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">testbyte</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">zero_payload</span><span class="p">):</span> <span class="c1">#tests payload bytes to decrease bit leakage
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xff</span><span class="p">):</span> <span class="c1">#returns before completion
</span>        <span class="n">prepend</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">zero_payload</span><span class="p">])</span> <span class="c1">#increases each byte
</span>        <span class="n">payload</span> <span class="o">=</span> <span class="s">"{:02x}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">"00"</span><span class="o">*</span><span class="p">(</span><span class="mi">16</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">zero_payload</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">prepend</span> <span class="o">+</span> <span class="n">payload</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sendinput</span><span class="p">(</span><span class="n">prepend</span> <span class="o">+</span> <span class="n">payload</span><span class="p">))</span> <span class="c1">#receives the bit leakage
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"Bits: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="n">bits</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="c1">#return incremented byte
</span>        <span class="k">elif</span> <span class="n">results</span> <span class="o">&gt;</span> <span class="n">bits</span><span class="p">:</span> <span class="c1">#LSB was already 0
</span>            <span class="k">return</span> <span class="s">"00"</span>

<span class="n">zero_payload</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#becomes a list of payload bytes that output 0 leakage bits
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x10</span><span class="p">):</span> <span class="c1">#for each byte
</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">testbyte</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">zero_payload</span><span class="p">)</span> <span class="c1">#lowers bit leakage if it can
</span>    <span class="n">zero_payload</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">#appends the returned byte
</span>    <span class="k">print</span><span class="p">(</span><span class="n">zero_payload</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="s">"00"</span><span class="p">:</span>
        <span class="n">bits</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">#for each byte that once had LSB
</span></code></pre></div></div>
<p>Because I am using payload “00000000000000000000000000000000”, I receive <code class="language-plaintext highlighter-rouge">leakage result: 8</code>.
For the first byte of the payload, increment value until it returns a bit leakage value lower than 8. If the bit count becomes higher, the byte “00” already returns LSB 0.
Repeat for each byte while prepending the bytes from the previous result to craft a “zero payload”.
Thus, when we submit the “zero payload”, the bit leakage will always be 0.</p>

<p><img src="/assets/files/picoctf/zero.png" alt="zeropayload" /></p>

<h2 id="solving">Solving</h2>
<p>Now, we solve!</p>

<p>Choose one payload byte to increment. Record the bit leakage and the incremented payload byte. Repeat for a certain amount of times (more details later).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">zero_payload</span> <span class="o">=</span> <span class="p">[</span><span class="s">'00'</span><span class="p">,</span> <span class="s">'01'</span><span class="p">,</span> <span class="s">'00'</span><span class="p">,</span> <span class="s">'01'</span><span class="p">,</span> <span class="s">'00'</span><span class="p">,</span> <span class="s">'00'</span><span class="p">,</span> <span class="s">'00'</span><span class="p">,</span> <span class="s">'01'</span><span class="p">,</span> <span class="s">'00'</span><span class="p">,</span> <span class="s">'02'</span><span class="p">,</span> <span class="s">'04'</span><span class="p">,</span> <span class="s">'01'</span><span class="p">,</span> <span class="s">'03'</span><span class="p">,</span> <span class="s">'03'</span><span class="p">,</span> <span class="s">'00'</span><span class="p">,</span> <span class="s">'00'</span><span class="p">]</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">zero_payload</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">data_byte</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">leak</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">position</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#first byte will be incremented
</span><span class="n">size</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#amount of increments/recordings
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="n">payload</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="s">"{:02x}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">zero_payload</span><span class="p">[</span><span class="n">position</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="c1">#increment
</span>    <span class="n">data_byte</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">payload</span><span class="p">[</span><span class="n">position</span><span class="p">],</span> <span class="mi">16</span><span class="p">))</span> <span class="c1">#record the byte
</span>    <span class="n">result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sendinput</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">payload</span><span class="p">)))</span> <span class="c1">#get the result (1 or 0)
</span>    <span class="n">leak</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">#record result
</span>
</code></pre></div></div>

<p>The bit leakage recorded will either be a 1 or a 0 (because the other 15 bytes return an LSB of 0).</p>

<p>What does this mean?</p>

<p>By curating a list of returned LSBs, it is possible to brute force the key byte by byte.</p>

<p><img src="/assets/files/picoctf/onebyte.png" alt="onebyte" /></p>

<p>As the payload byte increments, XORing with the static key changes its value, returning different Sbox numbers. Therefore, the list of leaked Sbox LSBs matches the Sbox LSBs of a given key byte XORed with the incremented payload byte.</p>

<p><img src="/assets/files/picoctf/bytesolve.png" alt="bytesolve" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xff</span><span class="p">):</span> <span class="c1">#tests all possible bytes
</span>    <span class="n">testleak</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="n">testleak</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbox</span><span class="p">[</span><span class="n">data_byte</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">^</span> <span class="n">key</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="c1">#gets LSB of possible Sbox match
</span>    <span class="k">if</span> <span class="n">leak</span> <span class="o">==</span> <span class="n">testleak</span><span class="p">:</span> <span class="c1">#leak list defined previously
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"MATCH: 0x{:02x}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="n">final</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">break</span>
</code></pre></div></div>

<p>We have successfully brute forced the first byte of the AES key. Now repeat 15 more times and we’ve got the encryption key!</p>

<p>For the python solution code, see “power.py”.</p>

<p><a href="https://asciinema.org/a/4FEbdqMm97Jis2h5a4r6zoXP7?speed=2&amp;autoplay=1"><img src="https://asciinema.org/a/4FEbdqMm97Jis2h5a4r6zoXP7.png" alt="asciinema" /></a></p>

<h2 id="final-thoughts">Final Thoughts</h2>
<p>Overall, this was a fun challenge and a fantastic introduction to side-channel attacks. After several hours of scripting, the key is produced in 90 seconds.</p>

<p>By the end of the competition, a total of 86 out of 6923 teams solved this challenge. Only 1% of the teams that competed managed to solve it.</p>

<details open=""><summary>Author's Note</summary>
<br />
Use the variable `SILENT=1` with `python3 power.py` to witness the beauty of the password oracle.
</details>]]></content><author><name>Ethan Morchy</name></author><category term="writeups" /><category term="cpa," /><category term="aes," /><category term="side-channel" /><summary type="html"><![CDATA[This is a writeup for the PicoCTF 2023 PowerAnalysisWarm challenge. Source code on github repo.]]></summary></entry><entry><title type="html">Piezo Impact Sensor Shield</title><link href="http://localhost:4000/projects/2023/02/25/piezo-shield.html" rel="alternate" type="text/html" title="Piezo Impact Sensor Shield" /><published>2023-02-25T00:00:00-08:00</published><updated>2023-02-25T00:00:00-08:00</updated><id>http://localhost:4000/projects/2023/02/25/piezo-shield</id><content type="html" xml:base="http://localhost:4000/projects/2023/02/25/piezo-shield.html"><![CDATA[<style>
img + em {
  display: block;
  text-align: center;
  margin: auto;
}
img.centered {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
img[alt=Bit-O-Honey] { width: 15%; margin: auto;}
img[alt=Shield of Daniel] { width: 50%; margin: auto;}
img[alt=Fritzing Model] { width: 50%; margin: auto;}
img[alt=Exposed] { width: 50%; margin: auto;}
img[alt=Covered] { width: 50%; margin: auto;}

/* Create two equal columns that floats next to each other */
.column {
  float: left;
  width: 50%;
  padding: 10px;
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}

iframe {
    display: block;
    aspect-ratio: 1080/1920;
    width: 25%;
    margin: 0 auto;
}
.aspect-ratio{
    position: relative;
    height: 0;
    padding-top: 0%;
}
</style>

<h1 id="what-is-a-bar-mitzvah">What is a Bar Mitzvah?</h1>
<p>A Bar Mitzvah is a Jewish rite of passage where a boy becomes a man in the eyes of Jewish talmudic law.</p>

<p>er custom, the congregation throws candy after they finish a 10 minute chanting of a Hebrew scripture. Usually it is Bit-O-Honey.</p>

<p><img src="/assets/files/bar-mitzvah/bit-o-honey.png" alt="Bit-O-Honey" class="centered" /></p>
<center><em>If God made a candy even</em> he <em>couldn't break.</em></center>

<h1 id="shield-of-daniel">Shield of Daniel</h1>
<p>When my little brother Daniel’s Bar Mitzvah rolled around several years later, he wanted something above and beyond as well. To block the candy, he crafted a wooden shield with a Jewish Star in the center. The humor is not lost on Hebrew-speaking people when the Jewish Star (known as the “Shield of David”) is superglued on a shield for a child’s Bar Mitzvah.</p>

<p><img src="/assets/files/bar-mitzvah/shield-of-daniel.jpeg" alt="Shield of Daniel" class="centered" />
<em>Shield of Daniel</em></p>

<p>In a moment of “divine inspiration”, I wondered how easy it could be to count how many candies were deflected by the shield.</p>

<h2 id="engineering-parts">Engineering Parts</h2>
<ul>
  <li>1 Arduino Nano</li>
  <li>5 100KΩ resistors</li>
  <li>1 3.7V LiPo Battery</li>
  <li>1 DC voltage boost converter</li>
  <li>1 TM1637 LED digit counter</li>
  <li>5 Piezo ceramic wafer plates</li>
  <li>1 push-button</li>
</ul>

<p>I took a deep dive into piezoelectricity several months prior to this project, and I was excited to finally have an applied project for this fascinating phenomenon. I will be using manufactured piezoelectric ceramic wafers instead of quartz crystals, but the piezoelectric process is essentially the same.</p>
<h3 id="piezoelectricity---quartz">Piezoelectricity - Quartz</h3>
<p>Piezoelectricity occurs when physical pressure is converted to an electric charge. Quartz is a beautiful example of piezoelecricity: when a precisely angled cut of quartz is struck, it releases voltage. One interesting quality of quartz is that every time it is struck with the same force, it releases the same voltage every time. This is why quartz is used in elecronic oscillators, clocks, and watches.</p>

<p><img src="/assets/files/bar-mitzvah/silicon-dioxide.gif" alt="Silicon Dioxide" class="centered" />
<em>This is how silicon dioxide materials (e.g quartz) create DC voltage with pressure</em></p>

<h2 id="physical-routing">Physical Routing</h2>

<p><img src="/assets/files/bar-mitzvah/shield-bb.jpg" alt="Fritzing Model" class="centered" /></p>

<p>The Piezo wafer sensors are connected to the analog ports to provide different feedback for various pressures. I also attached a 100KΩ resistor to each wafer to prevent damage to the Nano. I used whatever large-load resistors were lying around, but I recommend 1MΩ for future projects.</p>

<p>I used <a href="https://www.amazon.com/MakerFocus-Discharge-Integrated-Charging-Protection/dp/B07PZT3ZW2/">this</a> boost converter in my project because of its battery charging capabilities bundled with a pretty cool battery indicator. I desoldered the “key” button and bridged the connection with the push-button to allow turning on and prevent powering off.</p>

<h2 id="code">Code</h2>

<p>This is the first completed project where I used a C++ class in a practical scenario. Although OOP wasn’t necessary, it was interesting to complete. You can find the code <a href="https://github.com/emorchy/piezo-shield">here</a>.</p>

<h2 id="images">Images</h2>
<div class="row">
  <div class="column">
<div>
      <p><img src="/assets/files/bar-mitzvah/unconnected.jpg" alt="Exposed" class="centered" />
<em>Sensor Placement</em></p>
    </div>
  </div>
  <div class="column">
<div>
      <p><img src="/assets/files/bar-mitzvah/cardboard.jpg" alt="Covered" class="centered" />
<em>Final Product</em></p>
    </div>
  </div>
</div>

<div>
  <center>
  <iframe src="/assets/files/bar-mitzvah/livedemo.mp4" allowfullscreen=""></iframe>
  <p>
  <em>Shield Sensors Demo (2 candies thrown simultaneously)</em>
  </p>
</center>
</div>

<h2 id="final-thoughts">Final Thoughts</h2>
<p>The shield detected a total of 44 candies during his service. My brother got recognition of having the coolest and most well thought out Bar Mitzvah candy blocker in the synagogue. Sure, other children had tennis raquets or fly swatters, but they all cower at the might of Daniel’s mighty Shield!</p>

<p>Could I have used a better wiring system? Were the wire solder connections exposed? Could I have aesthetically made it much prettier and safer? Yes to all these questions. I had the idea to create an impact-sensor shield with a built in counter a week before the Bar Mitzvah began, and I managed to finish it the night before. I am amazed I could even finish on time, let alone it working as well as it did.</p>]]></content><author><name>Ethan Morchy</name></author><category term="projects" /><category term="engineering, piezo, arduino" /><summary type="html"><![CDATA[An impact sensor array for my little brother's shield to count deflected candy at his Bar Mitzvah.]]></summary></entry><entry><title type="html">RSA Talk</title><link href="http://localhost:4000/talks/2021/06/15/rsa-talk.html" rel="alternate" type="text/html" title="RSA Talk" /><published>2021-06-15T00:00:00-07:00</published><updated>2021-06-15T00:00:00-07:00</updated><id>http://localhost:4000/talks/2021/06/15/rsa-talk</id><content type="html" xml:base="http://localhost:4000/talks/2021/06/15/rsa-talk.html"><![CDATA[<h1 id="rsa-talk---beamer-presentation">RSA Talk - Beamer Presentation</h1>
<object data="/assets/files/rsa/beamer.pdf" width="100%" height="100%" type="application/pdf"></object>
<center><a href="/assets/files/rsa/beamer.pdf">Download</a></center>

<h1 id="rsa-talk---speaker-notes">RSA Talk - Speaker Notes</h1>
<object data="/assets/files/rsa/speaker_notes.pdf" width="100%" height="100%" type="application/pdf"></object>
<center><a href="/assets/files/rsa/speaker_notes.pdf">Download</a></center>]]></content><author><name>Ethan Morchy</name></author><category term="talks" /><category term="rsa," /><category term="latex" /><summary type="html"><![CDATA[A presentation for a group in 2021 about the application and vulnerabilities of RSA.]]></summary></entry><entry><title type="html">Cryptohack Euler’s Totient</title><link href="http://localhost:4000/writeups/2021/03/26/cryptohack.html" rel="alternate" type="text/html" title="Cryptohack Euler’s Totient" /><published>2021-03-26T00:00:00-07:00</published><updated>2021-03-26T00:00:00-07:00</updated><id>http://localhost:4000/writeups/2021/03/26/cryptohack</id><content type="html" xml:base="http://localhost:4000/writeups/2021/03/26/cryptohack.html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<p>Calculate Euler’s Totient (φn) using the Extended Euclidean Algorithm.
<!--excerpt--></p>
<details open="">
<summary>Description</summary>
RSA relies on the difficulty of the factorisation of the modulus N. If the primes can be found then we can calculate the Euler totient of N and thus decrypt the ciphertext.

Given N = p*q and two primes:

p = 857504083339712752489993810777

q = 1029224947942998075080348647219

What is the totient of N?
</details>

<h1 id="solution">Solution</h1>
<p>p = 857504083339712752489993810777
q = 1029224947942998075080348647219
N = (p-1)*(q-1)</p>

<p>#882564595536224140639625987657529300394956519977044270821168</p>
<h1 id="extended-mathematics">Extended Mathematics</h1>
<p>$$de - y(\phi(n)) \equiv 1 \pmod{\phi(n)}$$</p>

<p>$882564595536224140639625987657529300394956519977044270821168 = 13466661512370479891353372715527553906876367852923451955*65537 + 46333$</p>

<p>$65537 = 1*46333 + 19204$</p>

<p>$46333 = 2*19204 + 7925$</p>

<p>$19204 = 2*7925 + 3354$</p>

<p>$7925 = 2*3354 + 1217$</p>

<p>$3354 = 2*1217 + 920$</p>

<p>$1217 + 1*920 + 297$</p>

<p>$920 = 3*297 + 29$</p>

<p>$297 = 10*29 + 7$</p>

<p>$29 = 4*7 + 1$ (GCD: 1)</p>

<p>$1 = 29 - 4*7$</p>

<p>$= 29 - 4*(297 - 10*29) = 41*29 - 4*297$</p>

<p>$= 41(920-3*297) - 4*297 = 41*920 - 127*297$</p>

<p>$= 41*920 - 127(1217 - 1*920) = 168*920 - 127*1217$</p>

<p>$= 168(3354 - 2*1217) - 127*1217 = 168*3354 - 463*1217$</p>

<p>$= 168*3354 - 463(7925 - 2*3354) = 1094*3354 - 463*7925$</p>

<p>$= 1094*(19204 - 2*7925) - 463*7925 = 1094*19204 - 2651*7925$</p>

<p>$= 1094*19204 - 2651*(46333 - 2*19204) = 6396*19204 - 2651*46333$</p>

<p>$= 6396*(65537 - 1*46333) - 2651*46333 = 6396*65537 - 9047*46333$</p>

<p>$= 6396*65537 - 9047*(882564595536224140639625987657529300394956519977044270821168 - 121832886702415731577073962957377780195510499965398469843281*65537) = *65537 - 9047*882564595536224140639625987657529300394956519977044270821168$</p>

<p>$1 = 121832886702415731577073962957377780195510499965398469843281*65537 - 9047*882564595536224140639625987657529300394956519977044270821168$</p>

<p>$$d = 121832886702415731577073962957377780195510499965398469843281$$</p>

<h1 id="verification">Verification</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 == 121832886702415731577073962957377780195510499965398469843281*65537 - 9047*882564595536224140639625987657529300394956519977044270821168
#True
</code></pre></div></div>]]></content><author><name>Ethan Morchy</name></author><category term="writeups" /><category term="rsa," /><category term="cryptohack" /><summary type="html"><![CDATA[Calculate Euler’s Totient (φn) using the Extended Euclidean Algorithm.]]></summary></entry></feed>